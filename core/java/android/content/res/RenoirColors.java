package android.content.res;

import android.annotation.ColorInt;
import android.annotation.NonNull;
import android.annotation.SuppressLint;
import android.app.WallpaperColors;
import android.app.WallpaperManager;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.content.om.IOverlayManager;
import android.content.om.OverlayInfo;
import android.content.pm.UserInfo;
import android.os.ParcelFileDescriptor;
import android.os.RemoteException;
import android.os.ServiceManager;
import android.os.UserHandle;
import android.provider.Settings;
import android.util.Log;

import com.android.internal.graphics.ColorUtils;
import com.android.internal.graphics.palette.Palette;

import java.util.ArrayList;

/** @hide */
public class RenoirColors {

    private static Context context;

    // Renoir colorPalette
    private static int primaryAccent;
    private static int primaryGradient;
    private static int secondaryAccent;
    private static int secondaryGradient;
    private static int myterialAccent;
    private static int myterialGradient;
    // For UI Styles
    private static int myterialBackgroundLight;
    private static int myterialPrimaryLight;
    private static int myterialBackgroundDark;
    private static int myterialPrimaryDark;
    private static int transparentBackgroundLight;
    private static int transparentPrimaryLight;
    private static int transparentBackgroundDark;
    private static int transparentPrimaryDark;

    public static final int DEFAULT_COLOR_GEN = 16;
    public static final float DEFAULT_LIGHT_ALTERATION = 0.8f;
    public static final float DEFAULT_DARK_ALTERATION = 0.8f;
    private static final int DARK_BACKGROUND_COLOR = 0XFF070707;
    private static final int DARK_PRIMARY_COLOR = 0XFF121212;
    private static final int LIGHT_BACKGROUND_COLOR = 0XFFFAFAFA;
    private static final int LIGHT_PRIMARY_COLOR = 0XFFEAEAEA;
    public static final int COLOR_HUE = 0;
    public static final int COLOR_SAT = 1;
    public static final int COLOR_LIGHT = 2;

    private static final String TAG = "RenoirColors";

    /**
     * MonetWannabe 1.0
     * [accentColor] - generated from wallpaper
     * [accentColorBackground] - suitable for button backgrounds or inactive state of views
     * [accentColorOverlayLight] - fits best on QSPanel scrim background on light theme
     * [accentColorOverlayDark] - fits best on QSPanel scrim background on dark theme
     */
    public RenoirColors(@NonNull Context context) {
        this.context = context;
        if (isRenoirAvailable() && shouldForceLoad(context)) refreshColors(context);
    }

    /**
     * Generate a new accent based on wallpaper
     */
    private static void refreshColors(Context context) {
        Palette bitmapPalette = Palette.from(getBitmap(context)).generate();
        boolean usePalette = true;
        int fallbackColor = Color.TRANSPARENT;
        int primaryColorBase, secondaryColorBase;
        ArrayList<Integer> paletteList = new ArrayList<>();

        // Check if palette API is there, and we want to use palette API.
        if (bitmapPalette != null && usePalette) {
            /*
                The current best color hierarchy is the following:
                    1- Vibrant
                    2- Light Vibrant
                    3- Dark Vibrant
                    4- Muted
                    5- Dark Muted
                    6- Light Muted
            */
            int vibrantColor = bitmapPalette.getVibrantColor(fallbackColor);
            if (vibrantColor != fallbackColor) {
                paletteList.add(vibrantColor);
            }

            int lightVib = bitmapPalette.getLightVibrantColor(fallbackColor);
            if (lightVib != fallbackColor) {
                paletteList.add(lightVib);
            }

            int darkVib = bitmapPalette.getDarkVibrantColor(fallbackColor);
            if (darkVib != fallbackColor) {
                paletteList.add(darkVib);
            }

            int muted = bitmapPalette.getMutedColor(fallbackColor);
            if (muted != fallbackColor) {
                paletteList.add(muted);
            }

            int darkMuted = bitmapPalette.getMutedColor(fallbackColor);
            if (darkMuted != fallbackColor) {
                paletteList.add(darkMuted);
            }

            int lightMuted = bitmapPalette.getLightMutedColor(fallbackColor);
            if (lightMuted != fallbackColor) {
                paletteList.add(lightMuted);
            }
        } else {
            // Use our color generated by WallpaperColors
            WallpaperColors colors = WallpaperColors.fromBitmap(getBitmap(context));
            paletteList.add(colors.getPrimaryColor().toArgb());
            paletteList.add(colors.getSecondaryColor().toArgb());
        }
        // Get the main colors from the palette
        primaryColorBase = optimizeColorLighting(paletteList.get(0));
        secondaryColorBase = optimizeColorLighting(paletteList.get(1));
        // Do the color handling async now that we have the colors
        // First for accents
        primaryAccent = primaryColorBase;
        primaryGradient = generateAccentGradient(primaryColorBase);
        secondaryAccent = secondaryColorBase;
        secondaryGradient = generateAccentGradient(secondaryColorBase);
        myterialAccent = generateMyAccentColor(primaryColorBase);
        myterialGradient = generateAccentGradient(myterialAccent);
        // Now for UI Styles
        myterialBackgroundLight = ColorUtils.blendARGB(LIGHT_BACKGROUND_COLOR, primaryColorBase, 0.20f);
        myterialPrimaryLight = ColorUtils.blendARGB(LIGHT_PRIMARY_COLOR, primaryColorBase, 0.30f);
        myterialBackgroundDark = ColorUtils.blendARGB(DARK_BACKGROUND_COLOR, primaryColorBase, 0.15f);
        myterialPrimaryDark = ColorUtils.blendARGB(DARK_PRIMARY_COLOR, primaryColorBase, 0.25f);
        int transparentColorBaseLight = ColorUtils.blendARGB(Color.WHITE, primaryColorBase, 0.30f);
        int transparentColorBaseDark = ColorUtils.blendARGB(Color.BLACK, primaryColorBase, 0.30f);
        transparentBackgroundLight = adjustAlpha(transparentColorBaseLight, 0.8f);
        transparentPrimaryLight = adjustAlpha(transparentColorBaseLight,0.3f);
        transparentBackgroundDark = adjustAlpha(transparentColorBaseDark, 0.8f);
        transparentPrimaryDark = adjustAlpha(transparentColorBaseDark,0.3f);
    }

    public static void update(Context context) {
        refreshColors(context);
        reloadAssets("android");
        reloadAssets("com.android.systemui");
    }

    public int getAccentColor(int which) {
        int[] palette = {primaryAccent, primaryGradient};
        return palette[which];
    }

    public int getSecAccentColor(int which) {
        int[] palette = {secondaryAccent, secondaryGradient};
        return palette[which];
    }

    public int getMyAccentColor(int which) {
        int[] palette = {myterialAccent, myterialGradient};
        return palette[which];
    }

    public int getMyStyleColor(int which) {
        int[] uiColors = {myterialBackgroundLight, myterialPrimaryLight, myterialBackgroundDark, myterialPrimaryDark};
        return uiColors[which];
    }

    public int getTTStyleColor(int which) {
        int[] uiColors = {transparentBackgroundLight, transparentPrimaryLight, transparentBackgroundDark, transparentPrimaryDark};
        return uiColors[which];
    }

    public static int optimizeColorLighting(int color) {
        int finalColor = color;
        if (isTooLight(color)) {
            finalColor = ColorUtils.blendARGB(color, Color.BLACK, 0.05f);
        }
        if (isTooDark(color)) {
            finalColor = ColorUtils.blendARGB(color, Color.WHITE, 0.05f);
        }
        return finalColor;
    }

    public static int generateMyAccentColor(int color) {
        // This is completely inspired by the Material You
        // palette, so, let's soften the color
        int finalColor = ColorUtils.blendARGB(color, LIGHT_BACKGROUND_COLOR, 0.36f);
        // Then, let's apply the desat for a washed out effect, rooftop
        finalColor = tweakColorHsl(COLOR_SAT, finalColor, 0.88f);
        return finalColor;

    }

    public static int generateAccentGradient(int color) {
        // First, tweak the color hue, moving it a bit
        int finalColor = tweakColorHsl(COLOR_HUE, color, 0.85f);
        // Then, decolorize it to make the new color a bit more subtle
        finalColor = tweakColorHsl(COLOR_SAT, finalColor, 0.9f);
        return finalColor;

    }

    public static boolean shouldForceLoad(@NonNull Context context) {
        return isRenoStyleEnabled() || isRenoAccentEnabled(); // TODO: Refresh comparing the palette with the saved one
    }

    public static boolean isRenoirAvailable() {
        return true; // TODO: Make a system bool to toggle it
    }

    private static Bitmap getBitmap(Context context) {
        Bitmap bit;
        WallpaperManager walMan = WallpaperManager.getInstance(context);
        Drawable sysWallDrawable = walMan.getWallpaperInfo() == null ? walMan.getDrawable() :
                walMan.getWallpaperInfo().loadThumbnail(context.getPackageManager());
        if (sysWallDrawable instanceof BitmapDrawable && ((BitmapDrawable) sysWallDrawable).getBitmap() != null) {
            return ((BitmapDrawable) sysWallDrawable).getBitmap();
        } else {
            if (sysWallDrawable.getIntrinsicWidth() > 0 && sysWallDrawable.getIntrinsicHeight() > 0) {
                bit = Bitmap.createBitmap(sysWallDrawable.getIntrinsicWidth(), sysWallDrawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);
            } else {
                bit = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888);
            }
            Bitmap bitmap = bit;
            Canvas canvas = new Canvas(bitmap);
            sysWallDrawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
            sysWallDrawable.draw(canvas);
            return bitmap;
        }
    }

    public static int adjustAlpha(@ColorInt int color, float factor) {
        return ColorUtils.setAlphaComponent(color, Math.round((float) Color.alpha(color) * factor));
    }

    private static int getLightCousinColor(int darkColor) {
        return adjustAlpha(ColorUtils.blendARGB(darkColor, Color.WHITE, DEFAULT_LIGHT_ALTERATION), 1f);
    }

    private static int getDarkCousinColor(int lightColor) {
        return adjustAlpha(ColorUtils.blendARGB(lightColor, Color.BLACK, DEFAULT_DARK_ALTERATION), 1f);
    }

    private static double getDarkness(int color) {
        return (double) 1 - (0.299D * (double) Color.red(color) + 0.587D * (double) Color.green(color)) + 0.114D * (double) Color.blue(color) / (double) 255;
    }

    private static boolean isTooLight(int color) {
        return getDarkness(color) < 0.2D;
    }

    private static boolean isTooDark(int color) {
        return getDarkness(color) > 0.8D;
    }

    public static int tweakColorHsl(int which, int color, float amount) {
        float[] hslParams = new float[3];
        ColorUtils.colorToHSL(color, hslParams);
        // Conversion to tweak the color?
        hslParams[which] = hslParams[which] * amount;
        return ColorUtils.HSLToColor(hslParams);
    }

    private static void reloadAssets(String packageName) {
        try {
            IOverlayManager.Stub.asInterface(ServiceManager.getService("overlay"))
                    .reloadAssets(packageName, UserHandle.USER_CURRENT);
        } catch (RemoteException e) {
            Log.i(TAG, "Unable to reload resources for " + packageName);
        }
    }

    public static boolean isRenoAccentEnabled() {
        return context.getResources().getBoolean(
            com.android.internal.R.bool.config_isUsingRenoirAccent);
    }

    public static boolean isRenoStyleEnabled() {
        return context.getResources().getBoolean(
            com.android.internal.R.bool.config_isUsingRenoirUIStyle);
    }

    public static int getCurrentRenoAccentType() {
        return context.getResources().getInteger(
            com.android.internal.R.integer.config_isUsingRenoirAccentType);
    }

    public static int getCurrentRenoStyleType() {
        return context.getResources().getInteger(
            com.android.internal.R.integer.config_isUsingRenoirUIStyleType);
    }
}
